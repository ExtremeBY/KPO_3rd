#include "FST.h"

// Конструктор структуры RELATION (ребро перехода)
FST::RELATION::RELATION(unsigned char c, short nn)
{
    symbol = c; // Устанавливаем символ, по которому будет выполняться переход.
    nnode = nn; // Устанавливаем номер смежной вершины, куда будет происходить переход.
}

// Конструктор по умолчанию для структуры NODE (узел)
FST::NODE::NODE() {
    n_relation = 0; // Инициализируем количество ребер (переходов) как 0.
    RELATION* relations = NULL; // Устанавливаем указатель на массив ребер как NULL.
}

// Конструктор для структуры NODE с переменным числом ребер
FST::NODE::NODE(short n, RELATION rel, ...)
{
    n_relation = n; // Устанавливаем количество ребер (переходов) для этого узла.
    RELATION* p = &rel; // Указатель на первый переход передается через переменные аргументы.
    relations = new RELATION[n]; // Выделяем память для хранения n ребер.
    for (short i = 0; i < n; i++) relations[i] = p[i]; // Копируем переходы в массив.
}

// Конструктор для структуры FST (конечного автомата)
FST::FST::FST(const char* s, short ns, NODE n, ...) {
    string = s;  // Устанавливаем строку, которую автомат должен распознать.
    nstates = ns; // Устанавливаем количество состояний автомата.
    nodes = new NODE[ns]; // Выделить память для массива состояний (узлов автомата).
    NODE* p = &n; // Указатель на первый узел передается через переменные аргументы.
    for (int k = 0; k < ns; k++) nodes[k] = p[k]; // Копируем узлы в массив состояний.
    rstates = new short[nstates]; // Выделяем память для массива возможных состояний на каждой позиции.
    memset(rstates, 0xff, sizeof(short) * nstates); // Инициализируем массив rstates значением 0xff (все состояния недостижимы).
    rstates[0] = 0; // Начальное состояние автомата — нулевое.
    position = -1; // Устанавливаем начальную позицию перед первым символом строки.
}

// Функция для выполнения одного шага автомата
bool step(FST::FST& fst, short*& rstates)
{
    bool rc = false; // Изначально считаем, что переход не был выполнен.
    swap(rstates, fst.rstates); // Меняем местами указатели массивов текущих состояний.

    // Проходим по всем возможным состояниям автомата
    for (short i = 0; i < fst.nstates; i++) {
        if (rstates[i] == fst.position) // Проверяем, активны ли состояния на текущей позиции.
            // Проверяем все возможные переходы из текущего состояния
            for (short j = 0; j < fst.nodes[i].n_relation; j++)
            {
                // Если символ перехода совпадает с текущим символом строки
                if (fst.nodes[i].relations[j].symbol == fst.string[fst.position])
                {
                    // Автомат переходит в новое состояние (обновляем rstates для этого состояния).
                    fst.rstates[fst.nodes[i].relations[j].nnode] = fst.position + 1;
                    rc = true; // Переход выполнен успешно.
                };
            };
    };
    ret rc; // Возвращаем результат, указывающий, был ли выполнен переход.
}

// Функция выполнения конечного автомата для распознавания строки
bool FST::execute(FST& fst)
{
    short* rstates = new short[fst.nstates]; // Создаем временный массив состояний.
    memset(rstates, 0xff, sizeof(short) * fst.nstates); // Инициализируем его как недостижимый (значение 0xff).
    short lstring = strlen(fst.string); // Получаем длину строки.
    bool rc = true; // Переменная для отслеживания успешности шагов автомата.

    // Проходим по каждому символу строки
    for (short i = 0; i < lstring && rc; i++)
    {
        fst.position++; // Переходим к следующему символу строки.
        rc = step(fst, rstates); // Выполняем шаг автомата для текущего символа.
    };
    delete[] rstates; // Освобождаем память для временного массива состояний.

    // Если последний символ строки был распознан, проверяем, дошел ли автомат до конечного состояния.
    ret (rc ? (fst.rstates[fst.nstates - 1] == lstring) : rc);
}
